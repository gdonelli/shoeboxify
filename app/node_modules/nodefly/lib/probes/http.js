/*
 * Copyright (c) 2012 Dmitri Melikyan
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the 
 * "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to permit 
 * persons to whom the Software is furnished to do so, subject to the 
 * following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN 
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var crypto = require('crypto');
var util = require('util');
var nf = require('../nodefly');
var proxy = require('../proxy');
var samples = require('../samples');
var tiers = require('../tiers');
var _ = require('underscore');

module.exports = function(http) {
	
	// server probe
	proxy.before(http.Server.prototype, [ 'on', 'addListener' ], function(obj,
			args) {
		
		// store ref to server so we can pull current connections
		nf.server_obj = obj;

		if (nf.server_obj.connCount === undefined)
			nf.server_obj.connCount = 0;

		if (args[0] !== 'request')
			return;

		proxy.callback(args, -1, function(obj, args) {
			nf.server_obj.connCount++;

			if (nf.paused)
				return;

			var req = args[0];
			var res = args[1];
			var time = samples.time("HTTP Server", req.url, true);
			req.tiers = time.tiers = nf.extra = {};
			

			proxy.after(res, 'end', function(obj, args) {
				if (!time.done())
					return;

				try {
					if (!nf.expressAgg)
						nf.urlAgg._addUrlAtTimestamp(time.begin, req.url, time.ms,
								time.cputime, time.tiers);

					var httpTotal = time.ms;

					var tierTotal = _.reduce(time.tiers, function(memo, val, key) {
						return memo + val;
					}, 0);
					var node = httpTotal - tierTotal;

					//tiers.sample('node_in', { ms: node });
					tiers.sample('http', time);
				} catch (e) {
					console.log("problems!!!\n", e.stack);
					process.exit(0);
				}

				time.tiers.closed = true;
			}); // res.end
		},
		function(obj,args){
			nf.extra = undefined;
		}); // callback
		
	}); //server 

	// client probe
	function getClientResponseHandler(url, host, time) {
		return function handleResponseCb(obj, args, extra) {
			var res = args[0];
			
			proxy.before(res, [ 'on', 'addListener', 'once'], function(res, args) {
				if (args[0] !== 'end') return;
				
				proxy.callback(args, -1, function(obj, args, extra) {					
					if (!time || !time.done())
						return;
					
					nf.externalAgg._addUrlAtTimestamp(time.begin, url, time.ms,
							time.cputime);
					
					if (extra) {
						extra[host] = extra[host] || 0;
						extra[host] += time.ms;


						if (extra.closed) {
							if (typeof host === 'string')
								tiers.sample(host + '_out', time);
						}
						else {
							if (typeof host === 'string')
								tiers.sample(host + '_in', time);
						}

					}
				}); // res end cb
				
			}); // res end
		}
	}
	
	
	if (http.ClientRequest && http.ClientRequest.prototype) {
		proxy.before(http.ClientRequest.prototype, ['on', 'addListener', 'once'], function(req, args){
			if (args[0] !== 'response')
				return;
			
			if (req._headers) {
				var time = samples.time("HTTP Server", req.url, true);
				
				var url = req.method + ' ';
				if (req._headers.host) url += req._headers.host;
				url += req.path;
				//var url = util.format('%s %s:%s:%s', req.method, req.host, req.port, req.path);
				
				proxy.callback(args, -1, getClientResponseHandler(url, req._headers.host, time));
			} // has headers
		}); // before on/add/once
	} // http.ClientRequest
	
};