var EventEmitter = require('events').EventEmitter;
var proxy = require('./proxy');

var stats = require('./node-measured').createCollection();

var nf;


function checkNextTick(obj, args) {
	var t = Date.now();
	
	proxy.callback(args, -1, function(obj, args, extra) {
		var now = Date.now();
		var dt = now - t;
		
		if (dt > nf.blockThreshold) {
			/*
			var err = new Error('Queue Block');
			var stack = err.stack;
			
			var hasher = crypto.createHash('sha1');
			hasher.update(stack);
			var sha = hasher.digest('hex');
			nf.emit('queueBlock', { time: now, wait: dt, stack: stack, sha: sha });
			*/
			
			stats.aggregator('wait').mark(dt);
			stats.meter('rate').mark();
		}
	});	
}


function checkQueue(obj, args){
	var t = Date.now();
	proxy.callback(args, -1, function(obj, args, extra) {
		// dummy next tick to measure queue blockage
		process.nextTick(function(){ return; });
	});
}



function sample(code,time) {
	stats.aggregator(code).mark(time.ms);
}

var qStats;
var update;

function startEmitingQueueStats(){
	setInterval(function emitQueueStats(){
		stats._ts = nf.millis();
		qStats = stats.toJSON();
		
		if (!qStats || !qStats.rate || !qStats.wait) {
			update = [ 0, 0 ];
		}
		else {
			update = [qStats.rate.mean, qStats.wait.avg];
		}
		nf.metric(null, 'queue', update);
		//nf.emit('queue', update);
		
		stats.reset();
	}, 10*1000);
}


exports.init = function() {
	nf = global.nodefly;

	proxy.before(process, [ 'nextTick' ], checkNextTick);
	//proxy.before(EventEmitter.prototype, [ 'addListener', 'on', 'once' ], checkQueue);
	proxy.before(global, [ 'setTimeout', 'setInterval' ], checkQueue);
	
	startEmitingQueueStats();
};
